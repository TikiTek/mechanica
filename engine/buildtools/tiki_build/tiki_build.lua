-- Tiki Build Lua scripts, pack togther as a single file
-- DO NOT EDIT - this file is autogenerated - see README.md
-- To regenerate this file, run: premake5 release

-- third_party/datadumper.lua
--[[ DataDumper.lua
Copyright (c) 2007 Olivetti-Engineering SA
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
]]
local dumplua_closure = [[
local closures = {}
local function closure(t) 
  closures[#closures+1] = t
  t[1] = assert(loadstring(t[1]))
  return t[1]
end
for _,t in pairs(closures) do
  for i = 2,#t do 
    debug.setupvalue(t[1], i-1, t[i]) 
  end 
end
]]
local lua_reserved_keywords = {
  'and', 'break', 'do', 'else', 'elseif', 'end', 'false', 'for', 
  'function', 'if', 'in', 'local', 'nil', 'not', 'or', 'repeat', 
  'return', 'then', 'true', 'until', 'while' }
local function keys(t)
  local res = {}
  local oktypes = { stringstring = true, numbernumber = true }
  local function cmpfct(a,b)
    if oktypes[type(a)..type(b)] then
      return a < b
    else
      return type(a) < type(b)
    end
  end
  for k in pairs(t) do
    res[#res+1] = k
  end
  table.sort(res, cmpfct)
  return res
end
local c_functions = {}
for _,lib in pairs{'_G', 'string', 'table', 'math', 
    'io', 'os', 'coroutine', 'package', 'debug'} do
  local t = _G[lib] or {}
  lib = lib .. "."
  if lib == "_G." then lib = "" end
  for k,v in pairs(t) do
    if type(v) == 'function' and not pcall(string.dump, v) then
      c_functions[v] = lib..k
    end
  end
end
function DataDumper(value, varname, fastmode, ident)
  local defined, dumplua = {}
  -- Local variables for speed optimization
  local string_format, type, string_dump, string_rep = 
        string.format, type, string.dump, string.rep
  local tostring, pairs, table_concat = 
        tostring, pairs, table.concat
  local keycache, strvalcache, out, closure_cnt = {}, {}, {}, 0
  setmetatable(strvalcache, {__index = function(t,value)
    local res = string_format('%q', value)
    t[value] = res
    return res
  end})
  local fcts = {
    string = function(value) return strvalcache[value] end,
    number = function(value) return value end,
    boolean = function(value) return tostring(value) end,
    ['nil'] = function(value) return 'nil' end,
    ['function'] = function(value) 
      return string_format("loadstring(%q)", string_dump(value)) 
    end,
    userdata = function() error("Cannot dump userdata") end,
    thread = function() error("Cannot dump threads") end,
  }
  local function test_defined(value, path)
    if defined[value] then
      if path:match("^getmetatable.*%)$") then
        out[#out+1] = string_format("s%s, %s)\n", path:sub(2,-2), defined[value])
      else
        out[#out+1] = path .. " = " .. defined[value] .. "\n"
      end
      return true
    end
    defined[value] = path
  end
  local function make_key(t, key)
    local s
    if type(key) == 'string' and key:match('^[_%a][_%w]*$') then
      s = key .. "="
    else
      s = "[" .. dumplua(key, 0) .. "]="
    end
    t[key] = s
    return s
  end
  for _,k in ipairs(lua_reserved_keywords) do
    keycache[k] = '["'..k..'"] = '
  end
  if fastmode then 
    fcts.table = function (value)
      -- Table value
      local numidx = 1
      out[#out+1] = "{"
      for key,val in pairs(value) do
        if key == numidx then
          numidx = numidx + 1
        else
          out[#out+1] = keycache[key]
        end
        local str = dumplua(val)
        out[#out+1] = str..","
      end
      if string.sub(out[#out], -1) == "," then
        out[#out] = string.sub(out[#out], 1, -2);
      end
      out[#out+1] = "}"
      return "" 
    end
  else 
    fcts.table = function (value, ident, path)
      if test_defined(value, path) then return "nil" end
      -- Table value
      local sep, str, numidx, totallen = " ", {}, 1, 0
      local meta, metastr = (debug or getfenv()).getmetatable(value)
      if meta then
        ident = ident + 1
        metastr = dumplua(meta, ident, "getmetatable("..path..")")
        totallen = totallen + #metastr + 16
      end
      for _,key in pairs(keys(value)) do
        local val = value[key]
        local s = ""
        local subpath = path or ""
        if key == numidx then
          subpath = subpath .. "[" .. numidx .. "]"
          numidx = numidx + 1
        else
          s = keycache[key]
          if not s:match "^%[" then subpath = subpath .. "." end
          subpath = subpath .. s:gsub("%s*=%s*$","")
        end
        s = s .. dumplua(val, ident+1, subpath)
        str[#str+1] = s
        totallen = totallen + #s + 2
      end
      if totallen > 80 then
        sep = "\n" .. string_rep("  ", ident+1)
      end
      str = "{"..sep..table_concat(str, ","..sep).." "..sep:sub(1,-3).."}" 
      if meta then
        sep = sep:sub(1,-3)
        return "setmetatable("..sep..str..","..sep..metastr..sep:sub(1,-3)..")"
      end
      return str
    end
    fcts['function'] = function (value, ident, path)
      if test_defined(value, path) then return "nil" end
      if c_functions[value] then
        return c_functions[value]
      elseif debug == nil or debug.getupvalue(value, 1) == nil then
        return string_format("loadstring(%q)", string_dump(value))
      end
      closure_cnt = closure_cnt + 1
      local res = {string.dump(value)}
      for i = 1,math.huge do
        local name, v = debug.getupvalue(value,i)
        if name == nil then break end
        res[i+1] = v
      end
      return "closure " .. dumplua(res, ident, "closures["..closure_cnt.."]")
    end
  end
  function dumplua(value, ident, path)
    return fcts[type(value)](value, ident, path)
  end
  if varname == nil then
    varname = "return "
  elseif varname:match("^[%a_][%w_]*$") then
    varname = varname .. " = "
  end
  if fastmode then
    setmetatable(keycache, {__index = make_key })
    out[1] = varname
    table.insert(out,dumplua(value, 0))
    return table.concat(out)
  else
    setmetatable(keycache, {__index = make_key })
    local items = {}
    for i=1,10 do items[i] = '' end
    items[3] = dumplua(value, ident or 0, "t")
    if closure_cnt > 0 then
      items[1], items[6] = dumplua_closure:match("(.*\n)\n(.*)")
      out[#out+1] = ""
    end
    if #out > 0 then
      items[2], items[4] = "local t = ", "\n"
      items[5] = table.concat(out)
      items[7] = varname .. "t"
    else
      items[2] = varname
    end
    return table.concat(items)
  end
end
-- base/globals.lua
newoption{ trigger = "quiet", description = "does nothing" }
newoption{ trigger = "to", description = "Location for generated project files. Default: ./build" }
Platforms = {
Unknown= 0,
Windows= 1,
Linux= 2,
MacOS= 3
}
if not tiki then
tiki = {}
end
if not tiki.files then
tiki.files = {}
end
if not tiki.root_path then
tiki.root_path = path.getabsolute( path.getdirectory( _SCRIPT ) )
end
if not tiki.enable_unity_builds then
tiki.enable_unity_builds = true
end
if not _OPTIONS[ "to" ] then
_OPTIONS[ "to" ] = 'build'
end
if not tiki.generated_files_dir then
tiki.generated_files_dir = 'generated_files'
end
if not tiki.externals_dir then
tiki.externals_dir = 'externals'
end
local hostOs = os.host();
if hostOs == "windows" then
tiki.platform = Platforms.Windows
elseif hostOs == "bsd" or hostOs == "linux" or hostOs == "solaris" then
tiki.platform = Platforms.Linux
elseif hostOs == "macosx" then
tiki.platform = Platforms.MacOS
else
tiki.platform = Platforms.Unknown
end
if not tiki.svn_path then
tiki.svn_path = 'svn'
if tiki.platform == Platforms.Windows then
tiki.svn_path = tiki.svn_path .. '.exe'
end
end
if not tiki.git_path then
tiki.git_path = 'git'
if tiki.platform == Platforms.Windows then
tiki.git_path = tiki.git_path .. '.exe'
end
end

-- base/functions.lua

function throw( text )
print( debug.traceback() )
error( text )
end
function iff( expr, when_true, when_false )
if expr then
return when_true
else
return when_false
end
end
function class( init )
local cls = init
cls.__index = cls
return cls
end
function class_instance( class )
local new_instance = {}
copy_instance( new_instance, class )
setmetatable( new_instance, class )
return new_instance
end
function vardump(value, depth, key)
local linePrefix = ""
local spaces = ""
if key == "__index" then
return
end
if key ~= nil then
linePrefix = "["..key.."] = "
end
if depth == nil then
depth = 0
else
depth = depth + 1
for i=1, depth do spaces = spaces .. "  " end
end
if type(value) == 'table' then
mTable = getmetatable(value)
if mTable == nil then
print(spaces ..linePrefix.."(table) ")
else
print(spaces .."(metatable) ")
value = mTable
end
for tableKey, tableValue in pairs(value) do
vardump(tableValue, depth, tableKey)
end
elseif type(value)== 'function' or 
 type(value)== 'thread' or 
 type(value)== 'userdata' or
value== nil
then
print(spaces..tostring(value))
else
print(spaces..linePrefix.."("..type(value)..") "..tostring(value))
end
end
function table.uniq( array )
local hash = {}
local target = {}
for _,val in ipairs( array ) do
if not hash[ val ] then
hash[ val ] = true
target[ #target + 1 ] = val
end
end
return target
end
function table.remove_value( table2, value )
if type( table2 ) ~= "table" then
throw( "not a table" )
end
local count = #table2
for i = 0,count do
if table2[ i ] == value then
table.remove(table2, i )
break
end
end
end
function table.length( table2 )
local count = 0
for _ in pairs( table2 ) do
count = count + 1
end
return count
end
function copy_instance( target, source )
for name,value in pairs( source ) do
if ( type( value ) == "table" and name ~= "__index" ) then
target[ name ] = {}
copy_instance( target[ name ], value )
else
target[ name ] = value
end
end
end
function import( fname, base_dir )
if not base_dir then
base_dir = os.getcwd()
end
local fileName = path.join( base_dir, fname, fname .. ".lua" )
if not os.isfile( fileName ) then
throw( "Can not import " .. fname .. " from " .. base_dir )
end
dofile( fileName )
end
function tiki.isfile( file_path )
if tiki.files[ file_path ] then
return true
end
local local_path = path.join( tiki.root_path, file_path )
if os.isfile( local_path ) then
return true
end
return os.isfile( file_path )
end
function tiki.loadfile( file_path )
local file_func = nil
if tiki.files[ file_path ] then
file_func = assert( (loadstring or load)( tiki.files[ file_path ] ) )
else
local local_path = path.join( tiki.root_path, file_path )
if os.isfile( local_path ) then
file_func = assert( loadfile( local_path ) )
else
file_func = assert( loadfile( file_path ) )
end
end
if not file_func then
throw( "Failed to load script file: " .. file_path )
end
return file_func
end
function tiki.dofile( file_path )
local file_func = tiki.loadfile( file_path )
return file_func()
end
function get_config_dir( platform, configuration )
if platform == nil or configuration == nil then
throw( "get_config_dir: too few arguments." )
end
return _OPTIONS[ "to" ] .. "/" .. platform .. "/" .. configuration
end

-- base/configuration.lua

ConfigurationRuntimeTypeInformation = {
On= "On",
Off= "Off"
}
ConfigurationExceptionHandling = {
Default= "Defult",
On= "On",
Off= "Off",
SEH= "SEH"
}
ConfigurationFloatingPoint = {
Default= "Default",
Fast= "Fast",
Strict= "Strict"
}
ConfigurationOptimization = {
Off= "Off",
On= "On",
Debug= "Debug",
Size= "Size",
Speed= "Speed",
Full= "Full"
}
ConfigurationCppDialect = {
Default= "Default",
Cpp98= "C++98",
Cpp11= "C++11",
Cpp14= "C++14",
Cpp17= "C++17"
}
ConfigurationSymbols = {
Default= "Default",
Off= "Off",
On= "On",
FastLink= "FastLink",
Full= "Full"
}
ConfigurationPrecompiledHeader = {
Off= "Off",
On= "On"
}
ConfigurationMultiProcessorCompile = {
Off= "Off",
On= "On"
}
ConfigurationSettings = {
RuntimeTypeInformation= 1,
ExceptionHandling= 2,
FloatingPoint= 3,
Optimization= 4,
CppDialect= 5,
Symbols= 6,
PrecompiledHeader= 7,
MultiProcessorCompile= 8
}
Configuration = class{
defines = {},
settings = {},
flags = {},
include_dirs = {},
library_dirs = {},
library_files = {},
pre_build_steps = {},
post_build_steps = {}
};
local global_configuration_setttings = {
ConfigurationRuntimeTypeInformation,
ConfigurationExceptionHandling,
ConfigurationFloatingPoint,
ConfigurationOptimization,
ConfigurationCppDialect,
ConfigurationSymbols,
ConfigurationPrecompiledHeader,
ConfigurationMultiProcessorCompile
}
assert( #global_configuration_setttings == table.length( ConfigurationSettings ) )
function Configuration:new()
return class_instance( self );
end
function Configuration:check_base_path( base_path )
if type( base_path ) ~= "string" then
throw( "not base_path. too few arguments." )
end
end
function Configuration:set_define( name, value )
if type( name ) ~= "string" or (value ~= nil and type( value ) ~= "string") then
throw("[set_define] Invalid args.")
end
if value == nil then
table.insert( self.defines, name );
else
table.insert( self.defines, name .. "=" .. value );
end
end
function Configuration:set_flag( name )
if type( name ) ~= "string" then
throw("[set_flag] Invalid args.")
end
table.insert( self.flags, name );
end
function Configuration:set_setting( setting, value )
if type( setting ) ~= "number" or value == nil then
throw("[set_setting] Invalid args.")
end
if not table.contains( ConfigurationSettings, setting ) then
throw( "Invalid setting " .. setting )
end
local values = global_configuration_setttings[ setting ]
if not table.contains( values, value ) then
throw( "'" .. value .. "' is not a valid value for " .. table.keys( ConfigurationSettings )[ setting ] )
end
self.settings[ setting ] = value
end
function Configuration:add_include_dir( include_dir, base_path )
if type( include_dir ) ~= "string" then
throw "[add_include_dir] Invalid args.";
end
self:check_base_path( base_path );
table.insert( self.include_dirs, path.join( base_path, include_dir ) );
end
function Configuration:add_library_dir( library_dir, base_path )
if type( library_dir ) ~= "string" then
throw "[add_library_dir] Invalid args.";
end
self:check_base_path( base_path );
table.insert( self.library_dirs, path.join( base_path, library_dir ) );
end
function Configuration:add_library_file( library_filename )
if type( library_filename ) ~= "string" then
throw "[add_library_file] Invalid args.";
end
table.insert( self.library_files, library_filename );
end
function Configuration:add_pre_build_step( step_script, step_data, step_base_path )
if type( step_script ) ~= "string" or type( step_data ) ~= "table" then
throw "[add_pre_build_step] Invalid args.";
end
table.insert( self.pre_build_steps, { script = "actions/" .. step_script .. ".lua", base_path = step_base_path, data = step_data } );
end
function Configuration:add_post_build_step( step_script, step_data, step_base_path )
if type( step_script ) ~= "string" or type( step_data ) ~= "table" then
throw "[add_post_build_step] Invalid args.";
end
table.insert( self.post_build_steps, { script = "actions/" .. step_script .. ".lua", base_path = step_base_path, data = step_data } );
end
function Configuration:apply_configuration( target )
if type( target ) ~= "table" then
throw "[Configuration:apply_configuration] wrong target arguments.";
end
for setting, value in pairs( self.settings ) do
if target.settings[ setting ] and target.settings[ setting ] ~= value then
throw( "Settings conflict for '" .. table.keys( ConfigurationSettings )[ setting ] .. "' with value '" .. target.settings[ setting ] .. " ' and '" .. value .. "'." )
end
target.settings[ setting ] = value
end
target.defines = table.join( target.defines, self.defines );
target.flags = table.join( target.flags, self.flags );
target.include_dirs = table.join( target.include_dirs, self.include_dirs );
target.library_dirs = table.join( target.library_dirs, self.library_dirs );
target.library_files = table.join( target.library_files, self.library_files );
target.binary_dirs = table.join( target.binary_dirs, self.binary_dirs );
target.binary_files = table.join( target.binary_files, self.binary_files );
target.pre_build_steps = table.join( target.pre_build_steps, self.pre_build_steps );
target.post_build_steps = table.join( target.post_build_steps, self.post_build_steps );
end

-- base/configuration_set.lua

ConfigurationSet = class{
base_path = "",
global_config = nil,
platforms = {},
configurations = {},
ConfigurationSets = {} 
};
function ConfigurationSet:new()
local ConfigurationSet_new = class_instance( self );
ConfigurationSet_new.global_config= Configuration:new();
if tiki.external then
ConfigurationSet_new.base_path= tiki.external.export_path;
else
ConfigurationSet_new.base_path= os.getcwd();
end
return ConfigurationSet_new;
end
function ConfigurationSet:get_config( configuration, platform )
if ( ( configuration ~= nil and type( configuration ) ~= "string" ) or ( platform ~= nil and type( platform ) ~= "string" ) ) then
throw "[ConfigurationSet:get_config] Invalid args";
end
if ( configuration ~= nil and platform ~= nil ) then
if not self.ConfigurationSets[ platform ] then
self.ConfigurationSets[ platform ] = { configurations = {} };
end
if not self.ConfigurationSets[ platform ].configurations[ configuration ] then
self.ConfigurationSets[ platform ].configurations[ configuration ] = Configuration:new();
end
return self.ConfigurationSets[ platform ].configurations[ configuration ];
elseif ( configuration ~= nil and platform == nil ) then
if not self.configurations[ configuration ] then
self.configurations[ configuration ] = Configuration:new();
end
return self.configurations[ configuration ];
elseif ( configuration == nil and platform ~= nil ) then
if not self.platforms[ platform ] then
self.platforms[ platform ] = Configuration:new();
end
return self.platforms[ platform ];
else
return self.global_config;
end
return nil;
end
function ConfigurationSet:set_base_path( base_path )
if path.isabsolute( base_path ) then
self.base_path = base_path;
else
self.base_path = path.join( tiki.root_path, base_path );
end
end
function ConfigurationSet:set_define( name, value, configuration, platform )
self:get_config( configuration, platform ):set_define( name, value, self.base_path );
end
function ConfigurationSet:set_flag( name, configuration, platform )
self:get_config( configuration, platform ):set_flag( name, self.base_path );
end
function ConfigurationSet:set_setting( setting, value, configuration, platform )
self:get_config( configuration, platform ):set_setting( setting, value );
end
function ConfigurationSet:add_include_dir( include_dir, configuration, platform )
self:get_config( configuration, platform ):add_include_dir( include_dir, self.base_path );
end
function ConfigurationSet:add_library_dir( library_dir, configuration, platform )
self:get_config( configuration, platform ):add_library_dir( library_dir, self.base_path );
end
function ConfigurationSet:add_library_file( library_filename, configuration, platform )
self:get_config( configuration, platform ):add_library_file( library_filename );
end
function ConfigurationSet:add_pre_build_step( step_script, step_data, configuration, platform )
self:get_config( configuration, platform ):add_pre_build_step( step_script, step_data, self.base_path );
end
function ConfigurationSet:add_post_build_step( step_script, step_data, configuration, platform )
self:get_config( configuration, platform ):add_post_build_step( step_script, step_data, self.base_path );
end
-- base/external.lua

ExternalTypes = {
SVN= 'svn',
Git= 'git',
Custom= 'custom'
}
External = class{
url = nil,
type = nil,
version = nil,
file_path = nil,
export_path = nil,
import_file = nil,
import_func = nil,
module = nil
}
local global_external_storage = {}
function External:new( url )
local external_new = class_instance( self )
external_new.url= url:match( '(.*)@' ) or url:match( '(.*)$' )
external_new.version= url:match( '@(.*)$' )
local file_path = external_new.url
file_path = file_path:gsub( ":", "" )
file_path = file_path:gsub( "//", "/" )
external_new.file_path = file_path
local url_protocol = url:match( '^(.*):' )
if url_protocol == "git" then
external_new.type = ExternalTypes.Git
elseif url_protocol == "https" and external_new.url:endswith( ".git" ) then
external_new.type = ExternalTypes.Git
elseif url_protocol == "svn" then
external_new.type = ExternalTypes.SVN
elseif url_protocol == "https" then
external_new.type = ExternalTypes.Custom
else
   throw( "External type '" .. url_protocol .. "' used by '" .. url .. "' is not supported." )
end
if external_new.version == nil then
if external_new.type == ExternalTypes.SVN then
external_new.version = 'HEAD'
elseif external_new.type == ExternalTypes.Git then
external_new.version = 'master'
elseif external_new.type == ExternalTypes.Custom then
external_new.version = 'latest'
end
end
table.insert( global_external_storage, external_new )
return external_new
end
function External:check_svn()
local command_line = tiki.svn_path .. " --version > nul"
local exit_code = os.execute( command_line );
if not exit_code then
throw( 'svn could not be executed.' )
end
end
function External:check_git()
local command_line = tiki.git_path .. " --version > nul"
local exit_code = os.execute( command_line );
if not exit_code then
throw( 'git could not be executed.' )
end
end
local builtin_rmdir = os.rmdir
function bla(p)
local dirs = os.matchdirs(p .. "/*")
for _, dname in ipairs(dirs) do
print(dname)
bla(dname)
end
local files = os.matchfiles(p .. "/*")
for _, fname in ipairs(files) do
print(fname)
print( 'bla' )
print( os.remove(fname) )
end
builtin_rmdir(p)
end
function External:export()
local externals_dir = path.getabsolute( path.join( _OPTIONS[ "to" ], tiki.externals_dir ) )
self.export_path = path.join( externals_dir, self.file_path )
if self.type == ExternalTypes.SVN then
self:export_svn()
elseif self.type == ExternalTypes.Git then
self:export_git()
else
os.mkdir( self.export_path )
end
end
function External:export_svn()
self:check_svn()
local exists = os.isdir( self.export_path )
if exists then
local command_line = tiki.svn_path .. " info " .. self.export_path
local info_result = os.execute( command_line )
if not info_result then
exists = false
print( "External " .. self.url .. " has a broken export at '" .. self.export_path .. "', so it will be reexported." )
os.rmdir( self.export_path )
end
end
if not exists then
local command_line = tiki.svn_path .. " checkout " .. self.url .. "@" .. self.version .. " " .. self.export_path
local checkout_result = os.execute( command_line )
if checkout_result ~= 0 then
throw( "Failed to checkout '" .. self.url .. "' to '" .. self.export_path .. "' with exit code " .. checkout_result .. "." )
end
end
end
function External:export_git()
local base_command_line = tiki.git_path .. " -C " .. self.export_path .. " "
self:check_git()
local exists = os.isdir( self.export_path )
if exists then
print( "Check existants " .. self.url .."..." )
local info_result = os.outputof( base_command_line .. "status -s" )
if not info_result then
exists = false
print( "External " .. self.url .. " has a broken export at '" .. self.export_path .. "', so it will be reexported." )
os.rmdir( self.export_path )
end
end
if not exists then
print( "Clone " .. self.url .."..." )
local command_line = tiki.git_path .. " clone " .. self.url .. " " .. self.export_path
local clone_result = os.execute( command_line )
if not clone_result then
throw( "Failed to clone '" .. self.url .. "' to '" .. self.export_path .. "'." )
end
end
print( "Get version of " .. self.url .."..." )
local head = os.outputof( base_command_line .. "rev-parse --abbrev-ref HEAD" )
if head == "HEAD" then
head = os.outputof( base_command_line .. "rev-parse HEAD" )
end
if head ~= self.version then
print( "Fetch " .. self.url .."..." )
local fetch_result = os.execute( base_command_line .. "fetch" )
if not fetch_result then
throw( "Failed to fetch '" .. self.url .. "' in '" .. self.export_path .. "'." )
end
print( "Checkout " .. self.url .."..." )
local checkout_result = os.execute( base_command_line .. "checkout " .. self.version )
if not checkout_result then
throw( "Failed to checkout '" .. self.version .. "' for external '" .. self.url .. "'." )
end
end
end
function External:load()
local import_file = path.join( self.export_path, "tiki.lua" )
if not os.isfile( import_file ) then
import_file = path.join( "externals", self.file_path, "tiki.lua" )
end
print( "Load Module from " .. import_file )
if not tiki.isfile( import_file ) then
throw( "Could not find import file for '" .. self.url .. "'." )
end
self.import_file = import_file
self.import_func = tiki.loadfile( import_file )
self.module = Module:new( self.file_path:gsub( "/", '_' ) )
self.module:set_base_path( self.export_path )
module = self.module
tiki.external = self
self.import_func()
tiki.external = nil
module = nil
end
function find_external_module( url )
for _, external in ipairs( global_external_storage ) do
if external.url == url then
return external.module
end
end
local external = External:new( url )
external:export()
external:load();
return external.module
end

-- base/module.lua

Module = class{
name = nil,
module_type = 0,
import_func = nil,
config = nil,
module_dependencies = {},
external_dependencies = {},
source_files = {},
exclude_files = {},
optional_files = {},
stack_trace = ""
}
ModuleTypes = {
UnityCppModule= 0,
UnityCModule= 1,
FilesModule= 2
}
if not tiki.default_module_type then
tiki.default_module_type = ModuleTypes.UnityCppModule
end
local global_module_include_pathes = {}
local global_module_storage = {}
function add_module_include_path( include_path )
if path.isabsolute( include_path ) then
throw( "Please use relative pathes for module include pathes."  )
end
local module_include_path = path.getabsolute( path.join( path.getdirectory( _SCRIPT ), include_path ) )
for _, include_path in pairs( global_module_include_pathes ) do
if include_path == module_include_path then
return
end
end
table.insert( global_module_include_pathes, module_include_path )
end
function find_module( module_name, importer_name )
local import_name = module_name
local import_base = "."
local import_name_slash = module_name:find( "/" )
if import_name_slash ~= nil then
import_name = module_name:sub( import_name_slash + 1 )
import_base = module_name:sub( 0, import_name_slash - 1 )
end
for _, module in pairs( global_module_storage ) do
if module.name == import_name then
return module
end
end
local module_found = false
local module_filename = ""
for i, include_path in pairs( global_module_include_pathes ) do
local import_path = path.join( include_path, import_base )
local module_path = path.join( import_path, import_name )
local filename = path.join( module_path, import_name .. ".lua" )
if os.isfile( filename ) then
if module_found then
throw( "Module " .. import_name .. " has multiple file locations:\n" .. module_filename .. "\nand:\n" .. filename )
end
dofile( filename )
module_found = true
module_filename = filename
end
end
if not module_found then
print( "Module " .. module_name .. " not found. Search pathes:" )
for i,include_path in pairs( global_module_include_pathes ) do
print( "Path: " .. include_path )
end
throw( "Can not import " .. module_name )
end
if #global_module_storage > 0 then
local last_module = global_module_storage[ #global_module_storage ]
if last_module.name == import_name then
return last_module
end
end
print( "Model include directories:" )
for _, include_path in pairs( global_module_include_pathes ) do
print( include_path )
end
local error_text = "Module with name '" .. module_name .. "' not found."
if importer_name then
error_text = error_text .. " Imported by " .. importer_name .. "!"
end
throw( error_text )
return nil
end
function Module:new( name, initFunc )
if name == nil then
local source = debug.getinfo( 2 ).source
name = source:match( "([^/]+).lua$" )
end
for _,module in pairs( global_module_storage ) do
if ( module.name == name ) then
throw( "Module name already used: " .. name .. "\nmodule " .. module.stack_trace )
end
end
local module_new = class_instance( self )
module_new.name= name
module_new.config= ConfigurationSet:new()
module_new.module_type= tiki.default_module_type
module_new.stack_trace= debug.traceback()
table.insert( global_module_storage, module_new )
if ( initFunc ~= nil and type( initFunc ) == "function" ) then
initFunc( module_new )
end
return module_new
end
function Module:set_base_path( base_path )
self.config:set_base_path( base_path )
end
function Module:add_files( file_name, flags )
if type( file_name ) ~= 'string' then
throw( "invalid argument in add_files: file_name must be a string" )
end
local target_list = self.source_files
if type( flags ) == "table" then
if flags.exclude then
target_list = self.exclude_files
elseif flags.optional then
target_list = self.optional_files
end
end
table.insert( target_list, path.join( self.config.base_path, file_name ) )
end
function Module:set_define( name, value, configuration, platform )
self.config:set_define( name, value, configuration, platform )
end
function Module:set_flag( name, configuration, platform )
self.config:set_flag( name, configuration, platform )
end
function Module:set_setting( setting, value, configuration, platform )
self.config:set_setting( setting, value, configuration, platform )
end
function Module:add_include_dir( include_dir, configuration, platform )
self.config:add_include_dir( include_dir, configuration, platform )
end
function Module:add_library_dir( library_dir, configuration, platform )
self.config:add_library_dir( library_dir, configuration, platform )
end
function Module:add_library_file( library_filename, configuration, platform )
self.config:add_library_file( library_filename, configuration, platform )
end
function Module:add_pre_build_step( step_script, step_data, configuration, platform )
self.config:add_pre_build_step( step_script, step_data, configuration, platform )
end
function Module:add_post_build_step( step_script, step_data, configuration, platform )
self.config:add_post_build_step( step_script, step_data, configuration, platform )
end
function Module:add_dependency( module_name )
if not type( module_name ) == "string" then
throw( "module_name of a dependency must be a valid string." )
end
table.insert( self.module_dependencies, module_name )
end
function Module:add_external( url )
if not type( url ) == "string" then
throw( "url of a external dependency must be a valid string." )
end
table.insert( self.external_dependencies, url )
end
function Module:resolve_dependency( target_list )
for _, module_name in ipairs( self.module_dependencies ) do
local module = find_module( module_name, self.name )
if not table.contains( target_list, module ) then
table.insert( target_list, module )
module:resolve_dependency( target_list )
end
end
for _, url in ipairs( self.external_dependencies ) do
local module = find_external_module( url )
if not table.contains( target_list, module ) then
table.insert( target_list, module )
module:resolve_dependency( target_list )
end
end
end
function Module:finalize_files( project )
local is_unity_module = tiki.enable_unity_builds and (self.module_type == ModuleTypes.UnityCppModule or self.module_type == ModuleTypes.UnityCModule)
local all_files = {}
for _,pattern in pairs( self.source_files ) do
local matches = os.matchfiles( pattern )
if #matches == 0 then
throw( pattern .. "' pattern in '" .. self.name .. "' matches no files." )
end
for j, file_name in pairs( matches ) do
if not os.isfile( file_name ) then
throw("[finalize] '" .. file_name .. "'  in '" .. self.name .. "' don't exists.")
end
if not table.contains( all_files, file_name ) then
all_files[#all_files+1] = file_name
end
end
end
for _,pattern in pairs( self.optional_files ) do
local matches = ""
if path.isabsolute( pattern ) then
matches = { pattern }
else
matches = os.matchfiles( pattern )
end
for _,file_name in pairs( matches ) do
if not table.contains( all_files, file_name ) then
all_files[#all_files+1] = file_name
end
end
end
for _,pattern in pairs( self.exclude_files ) do
local matches = os.matchfiles( pattern )
for j,file_name in pairs( matches ) do
local index = table.indexof( all_files, file_name )
while index do
table.remove( all_files, index )
index = table.indexof( all_files, file_name )
end
end
end
if is_unity_module then
configuration( "Project" )
end
files( all_files )
configuration{}
if is_unity_module then
local ext = iff( self.module_type == ModuleTypes.UnityCModule, "c", "cpp" )
local unity_file_name = path.join( project.generated_files_dir, self.name .. "_unity." .. ext )
local c = {}
c[#c+1] = "// Unity file created by GENie"
c[#c+1] = ""
c[#c+1] = "#define TIKI_CURRENT_MODULE \"" .. self.name .. "\""
c[#c+1] = ""
for i,file_name in pairs( all_files ) do
if path.iscppfile( file_name ) then
local relative_file_name = path.getrelative( project.generated_files_dir, file_name )
c[#c+1] = string.format( "#include \"%s\"", relative_file_name )
end
end
local unity_content = table.concat( c, "\n" )
if _ACTION ~= "targets" then
local create_unity = true
if os.isfile( unity_file_name ) then
local unity_file = io.open( unity_file_name, "r" )
if unity_file ~= nil then
local unity_current_content = unity_file:read("*all")
if unity_current_content == unity_content then
create_unity = false
end
unity_file:close()
end
end
if create_unity then
print( "Create Unity file: " .. path.getname( unity_file_name ) )
local unity_file = io.open( unity_file_name, "w" )
if unity_file ~= nil then
unity_file:write( unity_content )
unity_file:close()
end
end
end
files( { unity_file_name } )
end
end
function Module:finalize(  config, project, solution )
if self.import_func ~= nil and type( self.import_func ) == "function" then
self.import_func( project, solution )
end
self:finalize_files( project )
self.config:get_config( nil, nil ):apply_configuration( config )
end
function Module:finalize_configuration( config, configuration, platform )
self.config:get_config( configuration, platform ):apply_configuration( config )
end

-- base/project.lua

ProjectTypes = {
ConsoleApplication= "ConsoleApp",
WindowApplication= "WindowedApp",
SharedLibrary= "SharedLib",
StaticLibrary= "StaticLib"
}
ProjectLanguages = {
Cpp= "C++",
Cs= "C#"
}
Project = class{
name = nil,
type = nil,
lang = ProjectLanguages.Cpp,
module = nil,
buildoptions = nil,
platforms = {},
configurations = {},
generated_files_dir = ''
}
local global_project_storage = {}
function find_project( project_name )
for i,project in pairs( global_project_storage ) do
if ( project.name == project_name ) then
return project
end
end
throw( "[find_project] Project with name '"..project_name.."' not found." )
return nil
end
function Project:new( name, platforms, configurations, project_type )
if not name then 
throw( "No Project name given." )
end
if type( platforms ) ~= "table" or type( configurations ) ~= "table" then 
throw( "Invalid Project platforms or configurations. Please provide an array." )
end
if not project_type then 
throw( "Invalid Project type. Please use the ProjectTypes enum." )
end
local project_new = class_instance( self )
project_new.name= name
project_new.type= project_type
project_new.module= Module:new( name .. "_project" )
project_new.configurations= configurations
project_new.platforms= platforms
table.insert( global_project_storage, project_new )
return project_new
end
function Project:set_base_path( base_path )
self.module:set_base_path( base_path )
end
function Project:add_files( file_name, flags )
self.module:add_files( file_name, flags )
end
function Project:set_define( name, value, configuration, platform )
self.module:set_define( name, value, configuration, platform )
end
function Project:set_flag( name, configuration, platform )
self.module:set_flag( name, configuration, platform )
end
function Project:set_setting( setting, value, configuration, platform )
self.module:set_setting( setting, value, configuration, platform )
end
function Project:add_include_dir( include_dir, configuration, platform )
self.module:add_include_dir( include_dir, configuration, platform )
end
function Project:add_library_dir( library_dir, configuration, platform )
self.module:add_library_dir( library_dir, configuration, platform )
end
function Project:add_library_file( library_filename, configuration, platform )
self.module:add_library_file( library_filename, configuration, platform )
end
function Project:add_pre_build_step( step_script, step_data, configuration, platform )
self.module:add_pre_build_step( step_script, step_data, configuration, platform )
end
function Project:add_post_build_step( step_script, step_data, configuration, platform )
self.module:add_post_build_step( step_script, step_data, configuration, platform )
end
function Project:add_dependency( module_name )
self.module:add_dependency( module_name )
end
function Project:add_external( url )
self.module:add_external( url )
end
function Project:add_install( pattern, target_path, configuration, platform )
local config = self.module.config:get_config( configuration, platform )
local step_data = {
pattern = pattern,
target = target_path
}
config:add_post_build_step( "install_binary", step_data )
end
function Project:finalize_create_directories()
self.generated_files_dir = path.join( _OPTIONS[ "to" ], tiki.generated_files_dir, self.name )
if not os.isdir( self.generated_files_dir ) then
print( "Create:" .. self.generated_files_dir )
os.mkdir( self.generated_files_dir )
end
end
function Project:finalize_create_configuration_directories( configuration, platform )
local build_dir = get_config_dir( platform, configuration )
if not os.isdir( build_dir ) then
print( "Create:" .. build_dir )
os.mkdir( build_dir )
end
return build_dir
end
function Project:finalize_config( config )
local final_defines = table.uniq( config.defines )
local final_flags = table.uniq( config.flags )
local final_include_dirs = table.uniq( config.include_dirs )
local final_library_dirs = table.uniq( config.library_dirs )
local final_library_files = table.uniq( config.library_files )
if final_defines then
defines( final_defines )
end
if final_flags then
flags( final_flags )
end
if final_include_dirs then
includedirs( final_include_dirs )
end
if final_library_dirs then
libdirs( final_library_dirs )
end
if final_library_files then
links( final_library_files )
end
for setting, value in pairs( config.settings ) do
if setting == ConfigurationSettings.RuntimeTypeInformation then
rtti( value )
elseif setting == ConfigurationSettings.ExceptionHandling then
exceptionhandling( value )
elseif setting == ConfigurationSettings.FloatingPoint then
floatingpoint( value )
elseif setting == ConfigurationSettings.Optimization then
optimize( value )
elseif setting == ConfigurationSettings.CppDialect then
cppdialect( value )
elseif setting == ConfigurationSettings.Symbols then
symbols( value )
elseif setting == ConfigurationSettings.PrecompiledHeader then
if value == ConfigurationPrecompiledHeader.Off then
flags{ "NoPCH" }
end
elseif setting == ConfigurationSettings.MultiProcessorCompile then
if value == ConfigurationMultiProcessorCompile.On then
flags{ "MultiProcessorCompile" }
end
else
throw( "Invalid setting " .. setting );
end
end
end
function Project:finalize_build_steps( config, build_dir )
local relative_build_dir = path.getrelative( _OPTIONS[ "to" ], build_dir )
local system_script = path.getrelative( _OPTIONS[ "to" ], path.join( tiki.root_path, "tiki_build.lua" ) )
if #config.pre_build_steps > 0 then
local pre_build_steps_filename = "pre_build_steps_" .. self.name .. ".lua"
local pre_build_steps_path = path.join( build_dir, pre_build_steps_filename )
local pre_build_steps_file = io.open( pre_build_steps_path, "w" )
if pre_build_steps_file ~= nil then
pre_build_steps_file:write( DataDumper( config.pre_build_steps ) )
pre_build_steps_file:close()
end
local command_line = {
_PREMAKE_COMMAND,
"--quiet",
"--systemscript=" .. system_script,
"--project=" .. self.name,
"--to=" .. relative_build_dir,
"--script=" .. path.join( relative_build_dir, pre_build_steps_filename ),
"buildsteps"
}
prebuildcommands{ table.concat( command_line, " " ) }
end
if #config.post_build_steps > 0 then
local post_build_steps_filename = "post_build_steps_" .. self.name .. ".lua"
local post_build_steps_path = path.join( build_dir, post_build_steps_filename )
local post_build_steps_file = io.open( post_build_steps_path, "w" )
if post_build_steps_file ~= nil then
post_build_steps_file:write( DataDumper( config.post_build_steps ) )
post_build_steps_file:close()
end
command_line = {
_PREMAKE_COMMAND,
"--quiet",
"--systemscript=" .. system_script,
"--project=" .. self.name,
"--to=" .. relative_build_dir,
"--script=" .. path.join( relative_build_dir, post_build_steps_filename ),
"buildsteps"
}
postbuildcommands{ table.concat( command_line, " " ) }
end
end
function Project:finalize_project( solution )
project( self.name )
kind( self.type )
language( self.lang )
if self.buildoptions then
buildoptions( self.buildoptions )
end
self:finalize_create_directories()
local config_project = Configuration:new()
if self.lang == ProjectLanguages.cpp then
config_project:set_define( "TIKI_PROJECT_NAME", self.name )
if self.type == ProjectTypes.sharedLibrary or self.type == ProjectTypes.staticLibrary then
config_project:set_define( "TIKI_BUILD_LIBRARY", "TIKI_ON" )
else
config_project:set_define( "TIKI_BUILD_LIBRARY", "TIKI_OFF" )
end
end
local modules = {}
self.module:resolve_dependency( modules )
self.module:finalize( config_project, self, solution )
for _,cur_module in pairs( modules ) do
cur_module:finalize( config_project, self, solution )
end
local config_platform = {}
for _,build_platform in pairs( self.platforms ) do
configuration{ build_platform }
config_platform[ build_platform ] = Configuration:new()
solution:finalize_configuration( config_platform[ build_platform ], nil, build_platform )
self.module:finalize_configuration( config_platform[ build_platform ], nil, build_platform )
for j,cur_module in pairs( modules ) do
cur_module:finalize_configuration( config_platform[ build_platform ], nil, build_platform )
end
end
local config_configuration = {}
for _,build_config in pairs( self.configurations ) do
configuration{ build_config }
config_configuration[ build_config ] = Configuration:new()
solution:finalize_configuration( config_configuration[ build_config ], build_config, nil )
self.module:finalize_configuration( config_configuration[ build_config ], build_config, nil )
for j,cur_module in pairs( modules ) do
cur_module:finalize_configuration( config_configuration[ build_config ], build_config, nil )
end
end
for _,build_platform in pairs( self.platforms ) do
for j,build_config in pairs( self.configurations ) do
if _ACTION ~= "targets" then
print( "Configuration: " .. build_platform .. "/" .. build_config )
end
configuration{ build_platform, build_config }
local build_dir = ''
if _ACTION ~= "targets" then
build_dir = self:finalize_create_configuration_directories( build_config, build_platform )
targetdir( build_dir )
debugdir( build_dir )
objdir( path.join( build_dir, "obj" ) )
end
local config = Configuration:new()
solution:finalize_configuration( config, build_config, build_platform )
self.module:finalize_configuration( config, build_config, build_platform )
for k,cur_module in pairs( modules ) do
cur_module:finalize_configuration( config, build_config, build_platform )
end
config_project:apply_configuration( config )
config_platform[ build_platform ]:apply_configuration( config )
config_configuration[ build_config ]:apply_configuration( config )
self:finalize_config( config )
if _ACTION ~= "targets" then
self:finalize_build_steps( config, build_dir )
end
end
end
end
-- base/solution.lua

Solution = class{
name = nil,
config = nil,
projects = {}
}
function add_extension( name )
local script_path = "extensions/extension." .. name .. ".lua"
tiki.dofile( script_path )
end
function Solution:new( name )
if not name then
local source = debug.getinfo( 2 ).source
name = source:match( "([^/]+)/genie.lua$" )
end
local solution_new = class_instance( self )
solution_new.name= name
solution_new.config= ConfigurationSet:new()
return solution_new
end
function Solution:add_project( project )
if type( project ) ~= "table" then
throw "[Solution:add_project] project argument is invalid."
end
if table.contains( self.projects, project ) then 
return
end
table.insert( self.projects, project )
end
function Solution:finalize()
local var_platforms = {}
local var_configurations = {}
for i,project in pairs( self.projects ) do
for i,platform in pairs( project.platforms ) do
if not table.contains( var_platforms, platform ) then 
table.insert( var_platforms, platform )
end
end
for j,configuration in pairs( project.configurations ) do
if not table.contains( var_configurations, configuration ) then 
table.insert( var_configurations, configuration )
end
end
end
table.insert( var_configurations, 'Project' )
workspace( self.name )
configurations( var_configurations )
platforms( var_platforms )
systemversion( "latest" )
location( _OPTIONS[ "to" ] )
if not os.isdir( _OPTIONS[ "to" ] ) then
print( "Create:" .. _OPTIONS[ "to" ] )
os.mkdir( _OPTIONS[ "to" ] )
end
while #self.projects > 0 do
local project = self.projects[ next( self.projects ) ]
if _ACTION ~= "targets" then
print( "Project: " .. project.name )
end
project:finalize_project( self )
table.remove_value( self.projects, project )
end
configuration{ "Project" }
kind( "Makefile" )
buildcommands{ _PREMAKE_COMMAND .. " /scripts=.. /to=" .. _OPTIONS[ "to" ] .. " " .. _ACTION }
end
function Solution:finalize_configuration( config, configuration, platform )
self.config:get_config( configuration, platform ):apply_configuration( config )
end
function finalize_default_solution( ... )
local projects = {...}
local source = debug.getinfo( 2 ).source
local name = source:match( "([^/]+)/premake5.lua$" )
local solution = Solution:new( name )
solution.config:set_define( "DEBUG", nil, "Debug" );
solution.config:set_define( "_DEBUG", nil, "Debug" );
solution.config:set_setting( ConfigurationSettings.Optimization, ConfigurationOptimization.Debug, "Debug" );
solution.config:set_setting( ConfigurationSettings.Symbols, ConfigurationSymbols.Full, "Debug" );
solution.config:set_setting( ConfigurationSettings.FloatingPoint, ConfigurationFloatingPoint.Fast, "Debug" );
solution.config:set_define( "NDEBUG", nil, "Release" );
solution.config:set_setting( ConfigurationSettings.Optimization, ConfigurationOptimization.Speed, "Release" );
solution.config:set_setting( ConfigurationSettings.Symbols, ConfigurationSymbols.Default, "Release" );
solution.config:set_setting( ConfigurationSettings.FloatingPoint, ConfigurationFloatingPoint.Fast, "Release" );
solution.config:set_define( "NDEBUG", nil, "Master" );
solution.config:set_setting( ConfigurationSettings.Optimization, ConfigurationOptimization.Speed, "Master" );
solution.config:set_setting( ConfigurationSettings.Symbols, ConfigurationSymbols.Default, "Master" );
solution.config:set_setting( ConfigurationSettings.FloatingPoint, ConfigurationFloatingPoint.Fast, "Master" );
solution.config:set_setting( ConfigurationSettings.CppDialect, ConfigurationCppDialect.Cpp11 );
solution.config:set_setting( ConfigurationSettings.RuntimeTypeInformation, ConfigurationRuntimeTypeInformation.Off );
solution.config:set_setting( ConfigurationSettings.ExceptionHandling, ConfigurationExceptionHandling.Off );
solution.config:set_setting( ConfigurationSettings.PrecompiledHeader, ConfigurationPrecompiledHeader.Off );
solution.config:set_setting( ConfigurationSettings.MultiProcessorCompile, ConfigurationMultiProcessorCompile.On );
for _, project in ipairs( projects ) do
solution:add_project( project )
end
solution:finalize()
end

-- base/buildsteps.lua
if _ACTION == 'buildsteps' then
newoption{ trigger = "script", description = "Script to load" }
newoption{ trigger = "project", description = "Name of the Project" }
end
if _ACTION == 'buildsteps' and not _OPTIONS[ 'script' ] then
error("No script specified.")
end
function is_build_required( source_file, target_file )
if not source_file then
throw( "is_build_required: no source_file specified." )
end
if not target_file then
throw( "is_build_required: no target_file specified." )
end
if not os.isfile( source_file ) then
throw( "is_build_required: " .. source_file .. " doesn't esists." )
end
if os.isfile( target_file ) then
if os.stat( source_file ).mtime > os.stat( target_file ).mtime then
return true
end
else
return true
end
return false
end
function execute_build_steps()
local config = {
project_name = _OPTIONS[ "project" ],
build_path = path.getabsolute( "." ),
output_path = path.getabsolute( _OPTIONS[ "to" ] )
}
local script_file = path.join( config.build_path, _OPTIONS[ "script" ] )
if not os.isfile( script_file )then
throw( "Script file not found at " .. script_file )
end
local build_actions = dofile( script_file )
for i, action in pairs( build_actions ) do
if not tiki.isfile( action.script )then
throw( "Action script file not found at " .. action.script )
end
local action_function = tiki.dofile( action.script )
if type( action_function ) ~= "function" then
throw( "Script in " .. action.script .. " doesn't contain a function." )
end
config.base_path = action.base_path
action_function( action.data, config )
end
end
newaction {
   trigger     = "buildsteps",
   description = "Execute Build Steps",
   execute     = execute_build_steps
}

-- base/targets.lua
newoption{ trigger = "targets_action", description = "Action to simulate" };
function print_targets(sln)
local vstudio_configs = premake.vstudio.buildconfigs( sln );
local result = "[\n"
for i,config in pairs( vstudio_configs ) do
if i ~= 1 then
result = result .. ", \n"
end
result = result .. "\t{ \"config\": \"" .. config[ "buildcfg" ] .. "\", \"platform\": \"" .. config[ "platform" ] .. "\" }"
end
result = result .. "\n]"
print( result );
end
newaction {
   trigger     = "targets",
   description = "Print Targets",
   onsolution  = print_targets
}
-- actions/install_binary.lua
tiki.files[ "actions/install_binary.lua" ] = "return function( data, config )\n" ..
"local files = os.matchfiles( path.join( config.output_path, data.pattern ) )\n" ..
"local target_path = path.join( global_configuration.root_path, data.target );\n" ..
"for _,file in pairs( files ) do\n" ..
"if is_build_required( file, target_path ) then\n" ..
"print( \"Install \" .. path.getname( file ) .. \" to \" .. target_path );\n" ..
"os.copyfile( file, target_path );\n" ..
"end\n" ..
"end\n" ..
"end"
-- actions/copy_file.lua
tiki.files[ "actions/copy_file.lua" ] = "-- Action to copy a file into output folder\n" ..
"return function( data, config )\n" ..
"local source_path = path.join( config.base_path, data.source )\n" ..
"if not os.isfile( source_path ) then\n" ..
"throw( \"[copy_binary] Source file not found at \" .. data.source )\n" ..
"end\n" ..
"if not data.target then\n" ..
"data.target = path.getname( data.source )\n" ..
"end\n" ..
"local target_path = path.join( config.output_path, data.target );\n" ..
"if is_build_required( source_path, target_path ) then\n" ..
"print( \"Copy \" .. data.source .. \" to output directory\" );\n" ..
"os.copyfile( source_path, target_path );\n" ..
"end\n" ..
"end"
-- extensions/extension.qt.lua
tiki.files[ "extensions/extension.qt.lua" ] = "-- library/buildtools/extensions/extension.qt\n" ..
"qt_dir = \"E:/Misc/Qt5.9.4/5.9.4/msvc2017_64\" --TODO: find real path e.g. os.getenv(\"QTDIR\")\n" ..
"local ui_script = path.getabsolute( path.join( path.getdirectory( _SCRIPT ), \"actions/qt_ui.lua\" ) );\n" ..
"local moc_script = path.getabsolute( path.join( path.getdirectory( _SCRIPT ), \"actions/qt_moc.lua\" ) );\n" ..
"local qrc_script = path.getabsolute( path.join( path.getdirectory( _SCRIPT ), \"actions/qt_qrc.lua\" ) );\n" ..
"local qrc_gen_script = path.getabsolute( path.join( path.getdirectory( _SCRIPT ), \"actions/qt_qrc_gen.lua\" ) );\n" ..
"function add_build_actions( module, pattern, prefix, ext, script )\n" ..
"local full_pattern = path.join( module.config.base_path, pattern );\n" ..
"local matches = os.matchfiles( full_pattern );\n" ..
"if #matches == 0 then\n" ..
"throw(\"[qt] '\" .. pattern .. \"' pattern matches no files.\");\n" ..
"end\n" ..
"for j, filename in pairs( matches ) do\n" ..
"local output_filename = prefix .. \"_\" .. path.getbasename( filename ) .. \".\" .. ext;\n" ..
"local step_data = {\n" ..
"source_filename = path.join( module.config.base_path, filename ),\n" ..
"output_filename = output_filename,\n" ..
"qt_dir = qt_dir\n" ..
"}\n" ..
"module:add_pre_build_step( script, step_data );\n" ..
"module:add_files( path.join( _OPTIONS[ \"generated_files_dir\" ], output_filename ), { optional = true } );\n" ..
"end\n" ..
"end\n" ..
"function Module:add_ui_files( pattern )\n" ..
"add_build_actions( self, pattern, \"ui\", \"h\", ui_script );\n" ..
"end\n" ..
"function Module:add_moc_files( pattern )\n" ..
"add_build_actions( self, pattern, \"moc\", \"cpp\", moc_script );\n" ..
"end\n" ..
"function Module:add_qrc_files( pattern )\n" ..
"add_build_actions( self, pattern, \"rcc\", \"cpp\", qrc_script );\n" ..
"end\n" ..
"function Module:add_qt_resources( pattern, prefix )\n" ..
"local qrc_filename = \"rcc_\" .. prefix .. \".qrc\";\n" ..
"local qrc_fullpath = path.join( _OPTIONS[ \"generated_files_dir\" ], qrc_filename );\n" ..
"local qrc_file = io.open( qrc_fullpath, \"a\" );\n" ..
"qrc_file:close();\n" ..
"local step_data = {\n" ..
"prefix = prefix,\n" ..
"source_pattern = path.join( self.config.base_path, pattern ),\n" ..
"output_filename = qrc_fullpath\n" ..
"}\n" ..
"self:add_pre_build_step( qrc_gen_script, step_data );\n" ..
"self:add_files( qrc_fullpath );\n" ..
"add_build_actions( self, qrc_fullpath, \"rcc\", \"cpp\", qrc_script );\n" ..
"end"
-- extensions/actions/qt_qrc.lua
tiki.files[ "extensions/actions/qt_qrc.lua" ] = "return function( data, config )\n" ..
"local output_path = path.join( config.build_path, \"qt_files\", config.project_name );\n" ..
"local output_file = path.join( output_path, data.output_filename );\n" ..
"if is_build_required( data.source_filename, output_file ) then\n" ..
"local rcc_exe = path.join( data.qt_dir, \"bin\\rcc.exe\" );\n" ..
"local name = path.getbasename( data.source_filename );\n" ..
"local command_line = rcc_exe .. \" \\\"\" .. data.source_filename .. \"\\\" -name \" .. name .. \" -o \\\"\" .. output_file .. \"\\\"\";\n" ..
"print( \"RCC: \" .. path.getname( data.source_filename ) );\n" ..
"if not os.execute( command_line ) then\n" ..
"throw( \"rcc returned an error\" );\n" ..
"end\n" ..
"end\n" ..
"end"
-- extensions/actions/qt_qrc_gen.lua
tiki.files[ "extensions/actions/qt_qrc_gen.lua" ] = "return function( data, config )\n" ..
"local matches = os.matchfiles( data.source_pattern );\n" ..
"if #matches == 0 then\n" ..
"throw(\"[qt] '\" .. data.source_pattern .. \"' pattern matches no files.\");\n" ..
"end\n" ..
"local content = {};\n" ..
"table.insert( content, \"<!DOCTYPE RCC>\" );\n" ..
"table.insert( content, \"<RCC version=\\\"1.0\\\">\" );\n" ..
"table.insert( content, \"\t<qresource prefix=\\\"\" .. data.prefix .. \"\\\">\" );\n" ..
"for j, filename in pairs( matches ) do\n" ..
"local alias = path.getname( filename );\n" ..
"table.insert( content, \"\t\t<file alias=\\\"\" .. alias .. \"\\\">\" .. filename .. \"</file>\" );\n" ..
"end\n" ..
"table.insert( content, \"\t</qresource>\" );\n" ..
"table.insert( content, \"</RCC>\" );\n" ..
"local content_string = table.concat( content, \"\n\" );\n" ..
"local current_content = io.readfile( data.output_filename );\n" ..
"if content_string ~= current_content then\n" ..
"print( \"Generate RCC: \" .. path.getname( data.output_filename ) );\n" ..
"io.writefile( data.output_filename, content_string );\n" ..
"end\n" ..
"end\n" ..
""
-- extensions/actions/qt_moc.lua
tiki.files[ "extensions/actions/qt_moc.lua" ] = "return function( data, config )\n" ..
"local output_path = path.join( config.build_path, \"qt_files\", config.project_name );\n" ..
"local output_file = path.join( output_path, data.output_filename );\n" ..
"if is_build_required( data.source_filename, output_file ) then\n" ..
"local moc_exe = path.join( data.qt_dir, \"bin\\moc.exe\" );\n" ..
"local moc_defines = \"-D_WINDOWS -DUNICODE -DWIN32 -DWIN64 -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB\"\n" ..
"local moc_include_dirs = {\n" ..
"path.join( data.qt_dir, \"include\" ),\n" ..
"path.join( data.qt_dir, \"include\\QtWidgets\" ),\n" ..
"path.join( data.qt_dir, \"include\\QtGui\" ),\n" ..
"path.join( data.qt_dir, \"include\\QtCore\" )\n" ..
"};\n" ..
"local moc_includes = \"-I\" .. table.concat( moc_include_dirs,\" -I\" );\n" ..
"local command_line = moc_exe .. \" \\\"\" .. data.source_filename .. \"\\\" -o \\\"\" .. output_file .. \"\\\" \" .. moc_defines .. \" \" .. moc_includes\n" ..
"print( \"MOC: \" .. path.getname( data.source_filename ) );\n" ..
"if not os.execute( command_line ) then\n" ..
"throw( \"moc return an error\" );\n" ..
"end\n" ..
"end\n" ..
"end"
-- extensions/actions/qt_ui.lua
tiki.files[ "extensions/actions/qt_ui.lua" ] = "return function( data, config )\n" ..
"local uic_exe = path.join( data.qt_dir, \"bin\\uic.exe\" );\n" ..
"local output_path = path.join( config.build_path, \"qt_files\", config.project_name );\n" ..
"print( \"UI: \" .. path.getname( data.source_filename ) );\n" ..
"local command_line = uic_exe .. \" -o \\\"\" .. data.output_filename .. \"\\\" \\\"\" .. data.source_filename .. \"\\\"\"\n" ..
"if not os.execute( command_line ) then\n" ..
"throw( \"uic return an error\" );\n" ..
"end\n" ..
"end"
-- externals/https/www.sqlite.org/tiki.lua
tiki.files[ "externals/https/www.sqlite.org/tiki.lua" ] = "-- https/sqlite.org\n" ..
"local version_name = \"sqlite-amalgamation-\" .. tiki.external.version\n" ..
"local download_path = path.join( tiki.external.export_path, \"source_code.zip\" )\n" ..
"if not os.isfile( download_path ) then\n" ..
"local download_url = \"https://www.sqlite.org/2020/\" .. version_name .. \".zip\"\n" ..
"print( \"Download: \" .. download_url )\n" ..
"local result_str, result_code = http.download( download_url, download_path )\n" ..
"if result_code ~= 200 then\n" ..
"throw( \"SQLite download failed with error \" .. result_code .. \": \" .. result_str )\n" ..
"end\n" ..
"zip.extract( download_path, tiki.external.export_path )\n" ..
"end\n" ..
"local sqlite_project = Project:new(\n" ..
"\"sqlite\",\n" ..
"{ \"x32\", \"x64\" },\n" ..
"{ \"Debug\", \"Release\" },\n" ..
"ProjectTypes.StaticLibrary\n" ..
");\n" ..
"sqlite_project.module.module_type = ModuleTypes.FilesModule;\n" ..
"sqlite_project:add_files( version_name .. \"/*.h\" );\n" ..
"sqlite_project:add_files( version_name .. \"/*.c\" );\n" ..
"module:add_library_file( \"sqlite\" );\n" ..
"module:add_include_dir( version_name );\n" ..
"module.import_func = function( project, solution )\n" ..
"solution:add_project( sqlite_project );\n" ..
"end\n" ..
""
-- externals/https/sourceforge.net/projects/libpsd/tiki.lua
tiki.files[ "externals/https/sourceforge.net/projects/libpsd/tiki.lua" ] = "-- https/sourceforge.net/projects/libpsd\n" ..
"local version_name = \"libpsd-0.9\"\n" ..
"local download_path = path.join( tiki.external.export_path, \"source_code.zip\" )\n" ..
"if not os.isfile( download_path ) then\n" ..
"local download_url = \"https://downloads.sourceforge.net/project/libpsd/libpsd/0.9/libpsd-0.9.zip\"\n" ..
"print( \"Download: \" .. download_url )\n" ..
"local result_str, result_code = http.download( download_url, download_path )\n" ..
"if result_code ~= 200 then\n" ..
"throw( \"libpsd download failed with error \" .. result_code .. \": \" .. result_str )\n" ..
"end\n" ..
"zip.extract( download_path, tiki.external.export_path )\n" ..
"end\n" ..
"local libpsd_project = Project:new(\n" ..
"\"libpsd\",\n" ..
"{ \"x32\", \"x64\" },\n" ..
"{ \"Debug\", \"Release\" },\n" ..
"ProjectTypes.StaticLibrary\n" ..
");\n" ..
"libpsd_project.module.module_type = ModuleTypes.FilesModule;\n" ..
"libpsd_project:add_include_dir( version_name .. \"/include\" );\n" ..
"libpsd_project:add_files( version_name .. \"/include/*.h\" );\n" ..
"libpsd_project:add_files( version_name .. \"/src/*.h\" );\n" ..
"libpsd_project:add_files( version_name .. \"/src/*.c\" );\n" ..
"module:add_library_file( \"libpsd\" );\n" ..
"module:add_include_dir( version_name .. \"/include\" );\n" ..
"module.import_func = function( project, solution )\n" ..
"solution:add_project( libpsd_project );\n" ..
"end\n" ..
""
-- externals/https/github.com/kimperator/T-Rex.git/tiki.lua
tiki.files[ "externals/https/github.com/kimperator/T-Rex.git/tiki.lua" ] = "-- https/github.com/kimperator/T-Rex.git\n" ..
"local trex_project = Project:new(\n" ..
"\"trex\",\n" ..
"{ \"x32\", \"x64\" },\n" ..
"{ \"Debug\", \"Release\" },\n" ..
"ProjectTypes.StaticLibrary\n" ..
");\n" ..
"trex_project.module.module_type = ModuleTypes.FilesModule;\n" ..
"trex_project:add_files( \"*.h\" );\n" ..
"trex_project:add_files( \"trex.c\" );\n" ..
"module:add_library_file( \"trex\" );\n" ..
"module:add_include_dir( \".\" );\n" ..
"module.import_func = function( project, solution )\n" ..
"solution:add_project( trex_project );\n" ..
"end"
-- externals/https/github.com/leethomason/tinyxml2.git/tiki.lua
tiki.files[ "externals/https/github.com/leethomason/tinyxml2.git/tiki.lua" ] = "-- https/github.com/leethomason/tinyxml2.git\n" ..
"local tinyxml_project = Project:new(\n" ..
"\"tinyxml2\",\n" ..
"{ \"x32\", \"x64\" },\n" ..
"{ \"Debug\", \"Release\" },\n" ..
"ProjectTypes.StaticLibrary\n" ..
");\n" ..
"tinyxml_project:add_files( \"tinyxml2.h\" );\n" ..
"tinyxml_project:add_files( \"tinyxml2.cpp\" );\n" ..
"module:add_library_file( \"tinyxml2\" );\n" ..
"module:add_include_dir( \".\" );\n" ..
"module.import_func = function( project, solution )\n" ..
"solution:add_project( tinyxml_project );\n" ..
"end"
-- externals/https/github.com/erincatto/box2d.git/tiki.lua
tiki.files[ "externals/https/github.com/erincatto/box2d.git/tiki.lua" ] = "-- https/github.com/erincatto/box2d.git\n" ..
"local box2d_project = Project:new(\n" ..
"\"box2d\",\n" ..
"{ \"x32\", \"x64\" },\n" ..
"{ \"Debug\", \"Release\" },\n" ..
"ProjectTypes.StaticLibrary\n" ..
");\n" ..
"box2d_project.module.module_type = ModuleTypes.FilesModule;\n" ..
"box2d_project:add_files( \"include/box2d/*.h\" );\n" ..
"box2d_project:add_files( \"src/**/*.cpp\" );\n" ..
"box2d_project:add_include_dir( \"include\" );\n" ..
"box2d_project:add_include_dir( \"src\" );\n" ..
"module:add_library_file( \"box2d\" );\n" ..
"module:add_include_dir( \"include\" );\n" ..
"module.import_func = function( project, solution )\n" ..
"solution:add_project( box2d_project );\n" ..
"end\n" ..
""
-- externals/https/github.com/nothings/stb.git/tiki.lua
tiki.files[ "externals/https/github.com/nothings/stb.git/tiki.lua" ] = "-- https/github.com/nothings/stb.git\n" ..
"module:add_files( \"*.c\" );\n" ..
"module:add_files( \"*.h\" );\n" ..
"module:add_include_dir( \".\" );\n" ..
""
-- externals/https/github.com/ocornut/imgui.git/tiki.lua
tiki.files[ "externals/https/github.com/ocornut/imgui.git/tiki.lua" ] = "-- https/github.com/ocornut/imgui.git\n" ..
"local imgui_project = Project:new(\n" ..
"\"imgui\",\n" ..
"{ \"x32\", \"x64\" },\n" ..
"{ \"Debug\", \"Release\" },\n" ..
"ProjectTypes.StaticLibrary\n" ..
");\n" ..
"imgui_project:add_files( \"*.h\" );\n" ..
"imgui_project:add_files( \"imgui.cpp\" );\n" ..
"imgui_project:add_files( \"imgui_draw.cpp\" );\n" ..
"imgui_project:add_files( \"imgui_widgets.cpp\" );\n" ..
"module:add_library_file( \"imgui\" );\n" ..
"module:add_include_dir( \".\" );\n" ..
"module.import_func = function( project, solution )\n" ..
"solution:add_project( imgui_project );\n" ..
"end\n" ..
""
-- externals/git/git.sv.nongnu.org/freetype/freetype2.git/tiki.lua
tiki.files[ "externals/git/git.sv.nongnu.org/freetype/freetype2.git/tiki.lua" ] = "-- git/git.sv.nongnu.org/freetype/freetype2.git\n" ..
"local freetype_project = Project:new(\n" ..
"\"freetype\",\n" ..
"{ \"x32\", \"x64\" },\n" ..
"{ \"Debug\", \"Release\" },\n" ..
"ProjectTypes.StaticLibrary\n" ..
");\n" ..
"freetype_project.module.module_type = ModuleTypes.FilesModule;\n" ..
"freetype_project:add_include_dir( \"include\" );\n" ..
"freetype_project:add_files( \"include/*.h\" );\n" ..
"freetype_project:add_files( \"src/autofit/autofit.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftbase.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftbbox.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftbitmap.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftfstype.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftgasp.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftglyph.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftgxval.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftinit.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftmm.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftotval.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftpatent.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftpfr.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftstroke.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftsynth.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftsystem.c\" );\n" ..
"freetype_project:add_files( \"src/base/fttype1.c\" );\n" ..
"freetype_project:add_files( \"src/base/ftwinfnt.c\" );\n" ..
"freetype_project:add_files( \"src/bdf/bdf.c\" );\n" ..
"freetype_project:add_files( \"src/cache/ftcache.c\" );\n" ..
"freetype_project:add_files( \"src/cff/cff.c\" );\n" ..
"freetype_project:add_files( \"src/cid/type1cid.c\" );\n" ..
"freetype_project:add_files( \"src/gzip/ftgzip.c\" );\n" ..
"freetype_project:add_files( \"src/lzw/ftlzw.c\" );\n" ..
"freetype_project:add_files( \"src/pcf/pcf.c\" );\n" ..
"freetype_project:add_files( \"src/pfr/pfr.c\" );\n" ..
"freetype_project:add_files( \"src/psaux/psaux.c\" );\n" ..
"freetype_project:add_files( \"src/pshinter/pshinter.c\" );\n" ..
"freetype_project:add_files( \"src/psnames/psmodule.c\" );\n" ..
"freetype_project:add_files( \"src/raster/raster.c\" );\n" ..
"freetype_project:add_files( \"src/sfnt/sfnt.c\" );\n" ..
"freetype_project:add_files( \"src/smooth/smooth.c\" );\n" ..
"freetype_project:add_files( \"src/truetype/truetype.c\" );\n" ..
"freetype_project:add_files( \"src/type1/type1.c\" );\n" ..
"freetype_project:add_files( \"src/type42/type42.c\" );\n" ..
"freetype_project:add_files( \"src/winfonts/winfnt.c\" );\n" ..
"if tiki.platform == Platforms.Windows then\n" ..
"freetype_project:add_files( \"builds/windows/ftdebug.c\" );\n" ..
"end\n" ..
"freetype_project:set_define( \"FT2_BUILD_LIBRARY\", \"1\" );\n" ..
"freetype_project:set_define( \"FT_DEBUG_LEVEL_ERROR\", \"1\" );\n" ..
"freetype_project:set_define( \"FT_DEBUG_LEVEL_TRACE\", \"1\" );\n" ..
"freetype_project:set_define( \"_CRT_SECURE_NO_WARNINGS\" );\n" ..
"module:add_library_file( \"freetype\" );\n" ..
"module:add_include_dir( \"include\" );\n" ..
"module.import_func = function( project, solution )\n" ..
"solution:add_project( freetype_project );\n" ..
"end\n" ..
""
